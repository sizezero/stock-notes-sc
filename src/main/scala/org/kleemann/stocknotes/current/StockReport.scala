package org.kleemann.stocknotes.current

import org.kleemann.stocknotes.{Currency, Date, Fraction, Ticker}
import org.kleemann.stocknotes.stock.{CashAccount, Shares, Stock}
import org.kleemann.stocknotes.stock.{Trade, Buy, Sell, Split}

/**
  * A Stock with Sells matched with the associated Buys.
  * If this is generated by the current report, there will be a single pretend sale that sells all remaining shares at today's date.
  * If this is a historical report, then all Sells for a particular date range will be included.
  *
  * @param stock The underlying stock data from the log directory.
  * @param mss The set of matched sells that have occurred. For current data, there is only one matched sell.
  * @param net The total value of all sales minus the sell commission
  * @param capGains The capital gains of this sale (gross-cost). This includes buy and sell commissions.
  * @param ltcgPercentage This is the percentage of shares sold that are ltcg.
  */
final case class StockReport(
  stock: Stock,
  mss: List[MatchedSell],
  net: Currency,
  capGains: Currency,
  ltcgPercentage: Double)

object StockReport {

  /**
    * If we currently own shares in this stock then make a pretend sale and generate the sell objects.
    *
    * @param stock the stock we want to pretend sell
    * @param price the current price
    * @param commission sell commission
    * @param today usually Date.today unless we are testing
    * @return a StockReport if there were shares to sell
    */
  private[current] def parseCompanyCurrentValue(stock: Stock, price: Currency, commission: Currency, today: Date): Option[StockReport] = {
    // we only want trades that are less than today; this is really just a problem for testing
    val trades = stock.trades.filter{ (t: Trade) => t.getDate() <= today }

    // We need to find all currently owned shares of the company.
    // Walk through each trade, accumulating the share count and multiple.
    // We only keep the share count.
    val (_, currentOwnedShares: Shares) =
      trades.foldLeft( (Fraction.one, Shares.zero) ) { case ((accMultiple, accShares), t) => t match {
        case Buy(_, shares, _, _)  => (accMultiple, accShares.add(shares, accMultiple))
        case Sell(_, shares, _, _) => (accMultiple, accShares.sub(shares, accMultiple))
        case Split(_, multiple)    => {
          val newMultiple = accMultiple * multiple
          // shares need to be adjusted since the final, pretend sell has a price at the new multiple
          val sharesAtNewMultiple = accShares.add(Shares.zero, newMultiple)
          (newMultiple, sharesAtNewMultiple)
        }
      }}

    if (currentOwnedShares == Shares.zero) None // nothing to sell so no report
    else {
      // This pretends we sell all of our remaining shares so the report
      // can show us what the current value of the shares are.
      val pretendSell = Sell(today, currentOwnedShares, price, commission)
      val pretendStock = stock.copy(trades = trades :+ pretendSell)
      parseCompanyDateRange(pretendStock, today, today)
    }
  }

  /**
    * This is the beginning of the common code of both the current report and the historical report.
    * Iterate through sells and match them with buys.
    *
    * @param stock the stock to analyze
    * @param start the earliest sell
    * @param end the latest sell
    * @return the StockReport if shares were sold within the specified date range
    */
  private[current] def parseCompanyDateRange(stock: Stock, start: Date, end: Date): Option[StockReport] = {

    // When a buy is encountered we add it to brss which is our accumulating list of BuyReadyToSells.
    // When a sell is encountered, the accumulated buy list is passed to the sell parser which may consume some of the buys
    // and a matched sell is returned that we accumulate.
    // We can ignore splits since the share values in the buys and sells already have multiples associated with them.
    val (_, mssReversed: List[MatchedSell]) = 
      stock.trades.foldLeft( (Vector[BuyReadyToSell](), List[MatchedSell]() ) ){ case ((brss, mss), trade) =>
        trade match {
          case buy: Buy  => (brss :+ BuyReadyToSell(buy), mss)
          case sell: Sell => {
            // even if the sell isn't in our date range, we have to process it so it will consume earlier buys
            val (ms: MatchedSell, unconsumed: Vector[BuyReadyToSell]) = MatchedSell.sell2MatchedSell(sell, brss)
            if (sell.date>=start && sell.date<=end) (unconsumed, ms :: mss)
            else                                    (unconsumed,       mss)
          }
          case _: Split => (brss, mss)
        }
      }
    val mss = mssReversed.reverse

    // if there are no matched sells for the company, then there's nothing to report
    if (mss.isEmpty) None
    else {

      // for net sum, only count sell commission, not buy commission or buys cost
      // this is the cash you get when you sell
      val net: Currency = mss.foldLeft(Currency.zero){ (acc, ms) => acc + ms.sell.gross - ms.sell.commission }

      // capital gains is what you actually earned
      // gross of each sell - sell commission - cost - buy commisions proportional to sold shares
      val capGains: Currency = mss.foldLeft(Currency.zero){ (acc: Currency, ms: MatchedSell) =>
        acc + ms.sell.gross - ms.sell.commission - ms.mbs.foldLeft(Currency.zero) { (acc2, mb) =>
          acc2 + mb.proportionalCost + mb.proportionalBuyCommission
        }
      }

      // percentage of shares that are ltcg vs short
      val m = Fraction.one // all calculations need to be at the same multiple but it doesn't matter which one
      val ltcgShares: Double = mss.foldLeft(0.0){ (acc, ms) =>
        acc + ms.mbs.foldLeft(0.0){ (acc, mb) => 
          acc + (if (mb.ltcg) mb.sold.atMult(m) else 0.0)
        } 
      }
      val totalShares: Double = mss.foldLeft(0.0){ (acc, ms) => acc + ms.sell.shares.atMult(m) }
      val ltcgPercentage = ltcgShares / totalShares

      Some(StockReport(stock, mss, net.truncate, capGains.truncate, ltcgPercentage))
    }
  }

}